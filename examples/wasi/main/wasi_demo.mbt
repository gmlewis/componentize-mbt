// Generated by `wit-bindgen` 0.1.0. DO NOT EDIT!

// export_name = "nonsense"
pub fn __export_nonsense() -> Int64 {
  let result0 = guest_impl.t0.unwrap().nonsense();
  result0
}

pub trait Guest {
  nonsense(Self) -> Int64;
}

pub(readonly) struct Wasi {
  random: WasiRandom
}

pub(readonly) struct WasiRandom {
  random: WasiRandomRandom
}

pub(readonly) type WasiRandomRandom Unit

/// Return `len` cryptographically-secure random or pseudo-random bytes.
/// 
/// This function must produce data at least as cryptographically secure and
/// fast as an adequately seeded cryptographically-secure pseudo-random
/// number generator (CSPRNG). It must not block, from the perspective of
/// the calling program, under any circumstances, including on the first
/// request and on requests for numbers of bytes. The returned data must
/// always be unpredictable.
/// 
/// This function must always return fresh data. Deterministic environments
/// must omit this function, rather than implementing it with deterministic
/// data.
pub fn get_random_bytes(self: WasiRandomRandom, len: Int64) -> Bytes {
  let ret_area = _rael_malloc(8) // align: 4
  ffi_wasi_random_random_get_random_bytes(len, ret_area)
  let l0 = _rael_load_i32(ret_area)
  let l1 = _rael_load_i32(ret_area + 4)
  let bytes2 = Bytes::make(l1, 0)
  _rael_memory_copy(_rael_bytes_data(bytes2), l0, l1)
  _rael_free(ret_area)
  bytes2
}

fn ffi_wasi_random_random_get_random_bytes(p0: Int64, p1: Int) = "wasi:random/random@0.2.0" "get-random-bytes"

/// Return a cryptographically-secure random or pseudo-random `u64` value.
/// 
/// This function returns the same type of data as `get-random-bytes`,
/// represented as a `u64`.
pub fn get_random_u64(self: WasiRandomRandom) -> Int64 {
  ffi_wasi_random_random_get_random_u64()
}

fn ffi_wasi_random_random_get_random_u64() -> Int64 = "wasi:random/random@0.2.0" "get-random-u64"


pub let wasi: Wasi = { random: { random: WasiRandomRandom(()) } }

struct GuestImpl {
  mut t0: Option[Guest]
} derive(Default)

let guest_impl: GuestImpl = GuestImpl::default()

pub fn init_guest[T: Guest](guest: T) -> Unit {
  guest_impl.t0 = Some(guest as Guest)
}

fn _rael_bytes_data(b: Bytes) -> Int = "$rael.bytes_data"

fn _rael_free(ptr: Int) = "$rael.free"

fn _rael_load_i32(ptr: Int) -> Int = "$rael.load_i32"

fn _rael_malloc(size: Int) -> Int = "$rael.malloc"

fn _rael_memory_copy(dst: Int, src: Int, len: Int) = "$rael.memory_copy"
